#!/usr/bin/env ruby
require 'open3'
require 'tempfile'
require 'fileutils'

TEST_REPO = ENV.fetch('TEST_REPO')
TMP_ROOT = File.absolute_path(Dir.mktmpdir)

at_exit do
  warn 'deleting tmp data'
  FileUtils.rm_rf(TMP_ROOT)
end

def main
  children = {}
  %w[repo1 repo2 repo3].each { |name| children[name] = create_child(name) }

  pool = File.join(TMP_ROOT, 'pool.git')
  source_name, source_path = children.first

  # This creates a bunch of refs in the top-level namespace we don't want.
  # However, they speed up the first fetch, so we keep them for now.
  run!(%W[git clone --quiet --bare --local #{File.basename(source_path)} #{File.basename(pool)}], File.dirname(pool))
  run!(%w[git remote remove origin], pool)
  run!(%w[git config advice.objectNameWarning false], pool)
  show_sizes([pool])

  add_child_to_pool(pool, source_name, source_path)
  run!(%W[git fetch --all --quiet], pool)

  # Now we can get rid of the top-level refs in pool.git.
  delete_top_level_refs(pool)

  children.each do |name, path|
    next if name == source_name

    add_child_to_pool(pool, name, path)
  end

  run!(%w[git remote -v], pool)
  show_sizes([pool] + children.values)

  children.each do |_, path|
    set_child_alternates(path, pool)

    # -l is important. Not sure about -A vs -a
    run!(%w[git repack -Ald --quiet], path)
  end

  show_sizes([pool] + children.values)

  target_name, target_path = 'repo4', child_path('repo4')
  children[target_name] = target_path
  clone_in_pool(pool, children['repo2'], target_name, target_path)

  show_sizes([pool] + children.values)

  run_pipeline([%w[git for-each-ref], %w[head -30]], target_path)
  run!(%w[cat objects/info/alternates], target_path)
end

def set_child_alternates(child, pool)
  open(File.join(child, 'objects/info/alternates'), 'w') do |f|
    f.puts File.join('..', '..', File.basename(pool), 'objects')
  end
end

def add_child_to_pool(pool, child_name, child_path)
  run!(%W[git remote add #{child_name} ../#{File.basename(child_path)}], pool)

  # this ensures every ref, including remote refs/tags, gets fetched
  run!(%W[git config remote.#{child_name}.fetch +refs/*:refs/remotes/#{child_name}/*], pool)

  # this prevents remote tags being fetched into the top-level refs/tags namespace
  run!(%W[git config remote.#{child_name}.tagopt --no-tags], pool)
end

def delete_top_level_refs(repo)
  run_pipeline!([
    %w[git for-each-ref --format=delete\ %(refname)],
    %w[grep -v ^delete\ refs/remotes/],
    %w[git update-ref --stdin],
  ], repo)
end

def run_pipeline(pipeline, dir)
  warn "#{File.basename(dir)}$ #{pipeline.map { |c| c.join(' ') }.join(' | ')}"

  statuses = Open3.pipeline(*pipeline, chdir: dir)

  statuses.all? { |s| s && s.success? }
end

def run_pipeline!(pipeline, dir)
  abort "failed" unless run_pipeline(pipeline, dir)
end


def show_sizes(paths)
  paths.each do |p|
    run!(%W[du -sh #{File.basename(p)}], File.dirname(p))
  end
end

def create_child(name)
  path = child_path(name)
  run!(%W[git clone --quiet --bare #{TEST_REPO} #{File.basename(path)}], File.dirname(path))
  clean_child(path)
  path
end

def clean_child(path)
  run!(%W[git remote remove origin], path)
  run!(%w[git config advice.objectNameWarning false], path)
  run!(%W[rm -rf hooks], path)
end

def child_path(name)
  File.join(TMP_ROOT, name + '.git')
end

def clone_in_pool(pool, source_path, target_name, target_path)
  run!(%W[git clone --quiet --bare --reference #{File.basename(pool)} #{File.basename(source_path)} #{File.basename(target_path)}], File.dirname(target_path))
  clean_child(target_path)
  add_child_to_pool(pool, target_name, target_path)
  set_child_alternates(target_path, pool)
end

def run!(cmd, dir=nil)
  dir ||= Dir.pwd
  cmd_s = cmd.join(' ')
  warn "#{File.basename(dir)}$ #{cmd_s}"
  start = Time.now
  abort "failed" unless system(*cmd, chdir: dir)
  delta = Time.now - start
  warn sprintf("time: %.3fs\n", delta) if delta > 1.0
end

main
