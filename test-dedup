#!/usr/bin/env ruby
require 'open3'
require 'tempfile'
require 'fileutils'

TEST_REPO = ENV.fetch('TEST_REPO')
TMP_ROOT = Dir.mktmpdir

at_exit do
  warn 'deleting tmp data'
  FileUtils.rm_rf(TMP_ROOT)
end

def main
  children = {}
  %w[repo1 repo2 repo3].each { |name| children[name] = create_child(name) }

  pool = File.join(TMP_ROOT, 'pool.git')
  source_name, source_path = children.first

  # This creates a bunch of refs in the top-level namespace we don't want.
  # However, they speed up the first fetch, so we keep them for now.
  run!(%W[git clone --quiet --bare --local #{source_path} #{File.basename(pool)}], File.dirname(pool))

  run!(%w[git config advice.objectNameWarning false], pool)
  show_sizes([pool])

  children.each do |name, path|
    add_child_to_pool(pool, name, path)
  end

  run!(%W[git fetch --all --quiet], pool)

  # Now we can get rid of the top-level refs in pool.git.
  delete_top_level_refs(pool)

  show_sizes([pool] + children.values)

  children.each do |name, path|
    open(File.join(path, 'objects/info/alternates'), 'w') do |f|
      f.puts File.join('..', '..', File.basename(pool), 'objects')
    end

    # -l is important. Not sure about -A vs -a
    run!(%w[git repack -Ald --quiet], path)
  end

  show_sizes([pool] + children.values)
end

def add_child_to_pool(pool, child_name, child_path)
  run!(%W[git remote add #{child_name} ../#{File.basename(child_path)}], pool)

  # this ensures every ref, including remote refs/tags, gets fetched
  run!(%W[git config remote.#{child_name}.fetch +refs/*:refs/remotes/#{child_name}/*], pool)

  # this prevents remote tags being fetched into the top-level refs/tags namespace
  run!(%W[git config remote.#{child_name}.tagopt --no-tags], pool)
end

def delete_top_level_refs(repo)
  run_pipeline!([
    %w[git for-each-ref --format=delete\ %(refname)],
    %w[grep -v ^delete\ refs/remotes/],
    %w[git update-ref --stdin],
  ], repo)
end

def run_pipeline!(pipeline, dir)
  warn "#{File.basename(dir)}$ #{pipeline.map { |c| c.join(' ') }.join(' | ')}"

  statuses = Open3.pipeline(*pipeline, chdir: dir)

  abort "failed" unless statuses.all? { |s| s && s.success? }
end

def show_sizes(paths)
  paths.each do |p|
    run!(%W[du -sh #{File.basename(p)}], File.dirname(p))
  end
end

def create_child(name)
  path = File.join(TMP_ROOT, name + '.git')
  run!(%W[git clone --quiet --bare #{TEST_REPO} #{File.basename(path)}], File.dirname(path))
  run!(%W[git remote remove origin], path)
  run!(%w[git config advice.objectNameWarning false], path)
  FileUtils.rm_rf(File.join(path, 'hooks'))
  path
end


def run!(cmd, dir=nil)
  dir ||= Dir.pwd
  cmd_s = cmd.join(' ')
  warn "#{File.basename(dir)}$ #{cmd_s}"
  start = Time.now
  abort "failed" unless system(*cmd, chdir: dir)
  delta = Time.now - start
  warn sprintf("time: %.3fs\n", delta) if delta > 1.0
end

main
