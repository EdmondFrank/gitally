#!/usr/bin/env ruby
require 'open3'
require 'tempfile'
require 'fileutils'

require_relative 'helper'

TEST_REPO = ENV.fetch('TEST_REPO')
TMP_ROOT = File.absolute_path(Dir.mktmpdir)

at_exit do
  warn 'deleting tmp data'
  FileUtils.rm_rf(TMP_ROOT)
end

def main
  children = {}
  %w[repo1 repo2 repo3].each { |name| children[name] = create_child(name) }

  # Create a pool based on repo1
  #
  pool = File.join(TMP_ROOT, 'pool.git')
  source_name, source_path = 'repo1', children['repo1']
  create_pool_repository(source_name, source_path, pool)
  link_repository_to_pool(pool, source_name, source_path)
  show_sizes([pool, children['repo1']])

  # Clone a new repo, repo4,  from repo1 (fork parent) within the pool
  #
  target_name, target_path = 'repo4', child_path('repo4')
  children[target_name] = target_path
  prepare_clone_in_pool(pool, source_path, target_name, target_path)
  link_repository_to_pool(pool, target_name, target_path)
  show_sizes([pool, source_path, target_path])

  # Repo4 leaves pool (e.g. fork switches to private)
  #
  repo_name, repo_path = 'repo4', child_path('repo4')
  # To make things interesting, ensure repo4 is deduplicated
  run!(%w[git repack --quiet -Ald], repo_path)
  run!(%w[find objects -type f], repo_path)
  show_sizes([repo_path])

  # Enter critical section where repo may not receive pushes (???)
  prepare_leave_pool(repo_path)
  unlink_repository_from_pool(pool, repo_name, repo_path)
  # Exit critical section

  # Sanity checks
  run!(%w[find objects -type f], repo_path)
  run!(%w[git fsck --connectivity-only], repo_path)
  show_sizes([repo_path])
end

def create_pool_repository(source_name, source_path, pool)
  puts '--- CreatePoolRepository'
  # Use --local to get Git to use hardlinks, which avoids copying objects and packfiles
  run!(%W[git clone --quiet --bare --local #{File.basename(source_path)} #{File.basename(pool)}], File.dirname(pool))

  # After the initial clone, the pool repository has top-level refs. This
  # is not what we want, we want these refs to live under refs/remotes.
  create_remote_in_pool(pool, source_name, source_path)
  run!(%W[git fetch --quiet #{source_name}], pool)

  # Now we can delete the top-level refs in the pool
  run!(%w[git remote remove origin], pool)
  delete_top_level_refs(pool)
  puts '---'
end

def create_remote_in_pool(pool, child_name, child_path)
  # It is important that the remote is a relative path, so that it is
  # stable across changing git data mountpoints.
  unless run(%W[git remote add #{child_name} ../#{File.basename(child_path)}], pool)
    run!(%W[git remote set-url #{child_name} ../#{File.basename(child_path)}], pool)
  end

  # this ensures every ref, including remote refs/tags, gets fetched
  run!(%W[git config remote.#{child_name}.fetch +refs/*:refs/remotes/#{child_name}/*], pool)

  # this prevents remote tags being fetched into the top-level refs/tags namespace
  run!(%W[git config remote.#{child_name}.tagopt --no-tags], pool)
end

def link_repository_to_pool(pool, child_name, child_path)
  puts '--- LinkRepositoryToPool'
  create_remote_in_pool(pool, child_name, child_path)

  open(File.join(child_path, 'objects/info/alternates'), 'w') do |f|
    # It is important that this is a relative path, so that it is stable across changing git data mountpoints.
    f.puts File.join('..', '..', File.basename(pool), 'objects')
  end

   puts '---'
end

def delete_top_level_refs(repo)
  # Delete every ref that does not start with 'refs/remotes/'
  run_pipeline!([
    %w[git for-each-ref --format=delete\ %(refname)],
    %w[grep -v ^delete\ refs/remotes/],
    %w[git update-ref --stdin],
  ], repo)
end

def show_sizes(paths)
  paths.each do |p|
    run!(%W[du -sh #{File.basename(p)}], File.dirname(p))
  end
end

def create_child(name)
  path = child_path(name)
  run!(%W[git clone --quiet --bare #{TEST_REPO} #{File.basename(path)}], File.dirname(path))
  clean_child(path)
  path
end

def clean_child(path)
  run!(%W[git remote remove origin], path)
  run!(%W[rm -rf hooks], path)
end

def child_path(name)
  File.join(TMP_ROOT, name + '.git')
end

def prepare_clone_in_pool(pool, source_path, target_name, target_path)
  puts '--- PrepareCloneInPool'

  # After this clone, objects/info/alternates is already set up but it
  # points to an absolute path. This is not what we want. This gets fixed
  # later by link_repository_to_pool.
  # 
  run!(%W[git clone --quiet --bare --local #{File.basename(source_path)} #{File.basename(target_path)}], File.dirname(target_path))
  clean_child(target_path)

  puts '---'
end

def prepare_leave_pool(repo_path)
  puts '--- PrepareLeavePool'

  # Because we are running 'git repack' _without_ '-l', Git will gather
  # all the objects it needs from the pool repository into a new
  # non-deduplicated packfile.
  run!(%w[git repack --quiet -a], repo_path)

  puts '---'
end

def unlink_repository_from_pool(pool, repo_name, repo_path)
  puts '--- UnlinkRepositoryFromPool'
  run!(%w[rm objects/info/alternates], repo_path)
  run!(%W[git remote remove #{repo_name}], pool)
  puts '---'
end

main
